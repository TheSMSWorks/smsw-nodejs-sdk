/**
 * The SMS Works API
 * The SMS Works provides a low-cost, reliable SMS API for developers. Pay only for delivered texts, all failed messages are refunded.
 *
 * The version of the OpenAPI document: 1.8.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import QueryMetadata from './QueryMetadata';

/**
 * The Query model module.
 * @module model/Query
 * @version 1.8.0
 */
class Query {
    /**
     * Constructs a new <code>Query</code>.
     * search parameters for querying the message database
     * @alias module:model/Query
     */
    constructor() { 
        
        Query.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Query</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Query} obj Optional instance to populate.
     * @return {module:model/Query} The populated <code>Query</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Query();

            if (data.hasOwnProperty('status')) {
                obj['status'] = ApiClient.convertToType(data['status'], 'String');
            }
            if (data.hasOwnProperty('credits')) {
                obj['credits'] = ApiClient.convertToType(data['credits'], 'Number');
            }
            if (data.hasOwnProperty('destination')) {
                obj['destination'] = ApiClient.convertToType(data['destination'], 'String');
            }
            if (data.hasOwnProperty('sender')) {
                obj['sender'] = ApiClient.convertToType(data['sender'], 'String');
            }
            if (data.hasOwnProperty('keyword')) {
                obj['keyword'] = ApiClient.convertToType(data['keyword'], 'String');
            }
            if (data.hasOwnProperty('from')) {
                obj['from'] = ApiClient.convertToType(data['from'], 'String');
            }
            if (data.hasOwnProperty('to')) {
                obj['to'] = ApiClient.convertToType(data['to'], 'String');
            }
            if (data.hasOwnProperty('limit')) {
                obj['limit'] = ApiClient.convertToType(data['limit'], 'Number');
            }
            if (data.hasOwnProperty('skip')) {
                obj['skip'] = ApiClient.convertToType(data['skip'], 'Number');
            }
            if (data.hasOwnProperty('unread')) {
                obj['unread'] = ApiClient.convertToType(data['unread'], 'Boolean');
            }
            if (data.hasOwnProperty('metadata')) {
                obj['metadata'] = QueryMetadata.constructFromObject(data['metadata']);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Query</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Query</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['status'] && !(typeof data['status'] === 'string' || data['status'] instanceof String)) {
            throw new Error("Expected the field `status` to be a primitive type in the JSON string but got " + data['status']);
        }
        // ensure the json data is a string
        if (data['destination'] && !(typeof data['destination'] === 'string' || data['destination'] instanceof String)) {
            throw new Error("Expected the field `destination` to be a primitive type in the JSON string but got " + data['destination']);
        }
        // ensure the json data is a string
        if (data['sender'] && !(typeof data['sender'] === 'string' || data['sender'] instanceof String)) {
            throw new Error("Expected the field `sender` to be a primitive type in the JSON string but got " + data['sender']);
        }
        // ensure the json data is a string
        if (data['keyword'] && !(typeof data['keyword'] === 'string' || data['keyword'] instanceof String)) {
            throw new Error("Expected the field `keyword` to be a primitive type in the JSON string but got " + data['keyword']);
        }
        // ensure the json data is a string
        if (data['from'] && !(typeof data['from'] === 'string' || data['from'] instanceof String)) {
            throw new Error("Expected the field `from` to be a primitive type in the JSON string but got " + data['from']);
        }
        // ensure the json data is a string
        if (data['to'] && !(typeof data['to'] === 'string' || data['to'] instanceof String)) {
            throw new Error("Expected the field `to` to be a primitive type in the JSON string but got " + data['to']);
        }
        // validate the optional field `metadata`
        if (data['metadata']) { // data not null
          QueryMetadata.validateJSON(data['metadata']);
        }

        return true;
    }


}



/**
 * The status of the messages you would like returned (either 'SENT', 'DELIVERED', 'EXPIRED', 'UNDELIVERABLE', 'REJECTED' or 'INCOMING')
 * @member {String} status
 */
Query.prototype['status'] = undefined;

/**
 * The number of credits used on the message. Floating point number.
 * @member {Number} credits
 */
Query.prototype['credits'] = undefined;

/**
 * The phone number of the recipient. Start UK numbers with 44 and drop the leading 0.
 * @member {String} destination
 */
Query.prototype['destination'] = undefined;

/**
 * The sender of the message (this can be the configured sender name for an outbound message or the senders phone number for an inbound message).
 * @member {String} sender
 */
Query.prototype['sender'] = undefined;

/**
 * The keyword used in the inbound message
 * @member {String} keyword
 */
Query.prototype['keyword'] = undefined;

/**
 * The date-time from which you would like matching messages
 * @member {String} from
 */
Query.prototype['from'] = undefined;

/**
 * The date-time to which you would like matching messages
 * @member {String} to
 */
Query.prototype['to'] = undefined;

/**
 * The maximum number of messages that you would like returned in this call. The default is 1000.
 * @member {Number} limit
 */
Query.prototype['limit'] = undefined;

/**
 * The number of results you would like to ignore before returning messages. In combination with the 'limit' parameter his can be used to page results, so that you can deal with a limited number in your logic at each time.
 * @member {Number} skip
 */
Query.prototype['skip'] = undefined;

/**
 * In queries for incoming messages ('status' is 'INCOMING'), specify whether you explicitly want unread messages (true) or read messages (false). Omit this parameter in other circumstances.
 * @member {Boolean} unread
 */
Query.prototype['unread'] = undefined;

/**
 * @member {module:model/QueryMetadata} metadata
 */
Query.prototype['metadata'] = undefined;






export default Query;

